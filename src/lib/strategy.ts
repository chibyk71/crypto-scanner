// src/lib/strategy.ts

/**
 * Trading strategy module that generates trade signals based on multi-timeframe technical analysis.
 * Combines indicators from primary (3-minute) and higher (1-hour) timeframes for confluence.
 */
import type { OhlcvData } from '../types';
import {
    calculateEMA,
    calculateRSI,
    calculateMACD,
    calculateStochastic,
    calculateATR,
    calculateBollingerBands,
    calculateOBV,
    checkMACrossover,
} from './indicators';

/**
 * Defines the structure of a trade signal generated by the trading strategy.
 * Includes trading decision, confidence level, and risk management parameters.
 */
export interface TradeSignal {
    symbol: string;
    signal: 'buy' | 'sell' | 'hold';
    confidence: number;
    reason: string[];
    stopLoss?: number;
    takeProfit?: number;
    trailingStopDistance?: number;
}

/**
 * Defines the structure of market data used as input for generating trade signals.
 * Contains arrays of price and volume data for a specific symbol.
 */
export interface MarketData {
    symbol: string;
    highs: number[];
    lows: number[];
    closes: number[];
    volumes: number[];
}

/**
 * Defines the input structure for the trading strategy, incorporating multi-timeframe data.
 */
export interface StrategyInput {
    symbol: string;
    primaryData: OhlcvData; // 3-minute timeframe
    htfData: OhlcvData;     // 1-hour timeframe for trend filter
    price: number;
    atrMultiplier: number;
    riskRewardTarget: number;
    trailingStopPercent: number;
}

// Configuration Constants (Can be moved to config/settings.ts)
const CONFIDENCE_THRESHOLD = 80; // Minimum score for a buy/sell signal
const HTF_TREND_POINTS = 40;    // Weight for higher timeframe trend alignment
const MA_TREND_POINTS = 25;     // Weight for moving average crossovers
const MOMENTUM_POINTS = 20;     // Weight for momentum indicators (RSI, MACD, Stochastic)
const VOLUME_POINTS = 15;       // Weight for volume-based indicators (OBV)
const MAX_SCORE_PER_SIDE = HTF_TREND_POINTS + MA_TREND_POINTS + 2 * MOMENTUM_POINTS + VOLUME_POINTS;

/**
 * Implements a trading strategy that generates trade signals using a weighted scoring system.
 * Analyzes multiple technical indicators across primary (3m) and higher (1h) timeframes.
 * Incorporates risk management with stop-loss, take-profit, and trailing stop mechanisms.
 */
export class Strategy {
    public readonly riskRewardTarget: number;
    public readonly atrMultiplier: number = 1.5;
    public readonly trailingStopPercent: number = 3;
    public lastAtr: null | number = null;

    constructor(riskRewardTarget = 3) {
        this.riskRewardTarget = riskRewardTarget;
    }

    /**
     * Generates a trade signal based on multi-timeframe and confluence analysis.
     * Uses primary (3-minute) and higher (1-hour) timeframe data to evaluate trend and momentum.
     * Applies risk management based on ATR and user-defined parameters.
     *
     * @param input - Data for primary (3m) and higher (1h) timeframes, plus configuration.
     * @returns TradeSignal with signal, confidence, reasons, and risk management levels.
     */
    public generateSignal(input: StrategyInput): TradeSignal {
        const { symbol, primaryData, htfData, price, atrMultiplier, riskRewardTarget, trailingStopPercent } = input;
        let buyScore = 0;
        let sellScore = 0;
        const reasons: string[] = [];

        // 1. Higher Timeframe (HTF) Trend Filter (1-hour)
        const htfCloses = htfData.closes;
        const htfEma200 = calculateEMA(htfCloses, 200);
        const htfLastPrice = htfCloses.at(-1)!;
        const htfLastEma = htfEma200.at(-1)!;
        let trendBias: 'bullish' | 'bearish' | 'none' = 'none';

        if (htfLastPrice > htfLastEma) {
            trendBias = 'bullish';
            buyScore += HTF_TREND_POINTS;
            reasons.push(`HTF (1H) Trend: Bullish (Price above EMA200) [${HTF_TREND_POINTS} pts]`);
        } else if (htfLastPrice < htfLastEma) {
            trendBias = 'bearish';
            sellScore += HTF_TREND_POINTS;
            reasons.push(`HTF (1H) Trend: Bearish (Price below EMA200) [${HTF_TREND_POINTS} pts]`);
        } else {
            reasons.push('HTF Trend: Neutral/Consolidating [0 pts]');
        }

        // 2. Primary Timeframe (TTF) Confluence (3-minute)
        const ttfHighs = primaryData.highs;
        const ttfLows = primaryData.lows;
        const ttfCloses = primaryData.closes;
        const ttfVolumes = primaryData.volumes;

        // Indicator Calculations
        const ema50 = calculateEMA(ttfCloses, 50);
        const ema200 = calculateEMA(ttfCloses, 200);
        const rsi = calculateRSI(ttfCloses, 10); // Faster RSI for short-term momentum
        const macd = calculateMACD(ttfCloses);
        const stoch = calculateStochastic(ttfHighs, ttfLows, ttfCloses, 14, 3);
        const bb = calculateBollingerBands(ttfCloses);
        const obv = calculateOBV(ttfCloses, ttfVolumes);
        const atr = calculateATR(ttfHighs, ttfLows, ttfCloses, 12);

        // Moving Average Trend
        const ttfTrend = ema50.at(-1)! > ema200.at(-1)! ? 'bullish' : 'bearish';
        if (ttfTrend === 'bullish') {
            buyScore += MA_TREND_POINTS;
            reasons.push(`TTF (3m) Trend: Bullish (EMA50 > EMA200) [${MA_TREND_POINTS} pts]`);
        } else {
            sellScore += MA_TREND_POINTS;
            reasons.push(`TTF (3m) Trend: Bearish (EMA50 < EMA200) [${MA_TREND_POINTS} pts]`);
        }

        // Moving Average Crossover
        const maCross = checkMACrossover(ema50, ema200);
        if (maCross === 'bullish') {
            buyScore += MA_TREND_POINTS;
            reasons.push(`TTF Golden Cross detected [${MA_TREND_POINTS} pts]`);
        } else if (maCross === 'bearish') {
            sellScore += MA_TREND_POINTS;
            reasons.push(`TTF Death Cross detected [${MA_TREND_POINTS} pts]`);
        }

        // RSI Momentum
        const rsiNow = rsi.at(-1)!;
        if (rsiNow > 60 && trendBias !== 'bearish') {
            buyScore += MOMENTUM_POINTS;
            reasons.push(`TTF RSI > 60: Strong bullish momentum [${MOMENTUM_POINTS} pts]`);
        } else if (rsiNow < 40 && trendBias !== 'bullish') {
            sellScore += MOMENTUM_POINTS;
            reasons.push(`TTF RSI < 40: Strong bearish momentum [${MOMENTUM_POINTS} pts]`);
        }
        if (rsiNow >= 75 && trendBias !== 'bullish') {
            sellScore += MOMENTUM_POINTS;
            reasons.push(`TTF RSI >= 75: Overbought reversal [${MOMENTUM_POINTS} pts]`);
        } else if (rsiNow <= 25 && trendBias !== 'bearish') {
            buyScore += MOMENTUM_POINTS;
            reasons.push(`TTF RSI <= 25: Oversold bounce [${MOMENTUM_POINTS} pts]`);
        }

        // MACD Momentum
        const macdNow = macd.at(-1)!;
        if (macdNow.histogram && macdNow.histogram > 0 && trendBias !== 'bearish') {
            buyScore += MOMENTUM_POINTS;
            reasons.push(`TTF MACD histogram positive: Bullish momentum [${MOMENTUM_POINTS} pts]`);
        } else if (macdNow.histogram && macdNow.histogram < 0 && trendBias !== 'bullish') {
            sellScore += MOMENTUM_POINTS;
            reasons.push(`TTF MACD histogram negative: Bearish momentum [${MOMENTUM_POINTS} pts]`);
        }

        // Stochastic Oscillator
        const stochNow = stoch.at(-1)!;
        if (stochNow.k < 20 && stochNow.k > stochNow.d && trendBias !== 'bearish') {
            buyScore += MOMENTUM_POINTS / 2;
            reasons.push(`TTF Stochastic turning up from oversold [${MOMENTUM_POINTS / 2} pts]`);
        } else if (stochNow.k > 80 && stochNow.k < stochNow.d && trendBias !== 'bullish') {
            sellScore += MOMENTUM_POINTS / 2;
            reasons.push(`TTF Stochastic turning down from overbought [${MOMENTUM_POINTS / 2} pts]`);
        }

        // Bollinger Bands
        const bbNow = bb.at(-1)!;
        if (price <= bbNow.lower && trendBias !== 'bearish') {
            buyScore += MOMENTUM_POINTS / 2;
            reasons.push(`TTF Price near/below Bollinger lower band [${MOMENTUM_POINTS / 2} pts]`);
        } else if (price >= bbNow.upper && trendBias !== 'bullish') {
            sellScore += MOMENTUM_POINTS / 2;
            reasons.push(`TTF Price near/above Bollinger upper band [${MOMENTUM_POINTS / 2} pts]`);
        }

        // On-Balance Volume
        if (obv.length >= 10 && obv.at(-1)! > obv.at(-10)! && trendBias !== 'bearish') {
            buyScore += VOLUME_POINTS;
            reasons.push(`TTF OBV rising: Bullish volume trend [${VOLUME_POINTS} pts]`);
        } else if (obv.length >= 10 && obv.at(-1)! < obv.at(-10)! && trendBias !== 'bullish') {
            sellScore += VOLUME_POINTS;
            reasons.push(`TTF OBV falling: Bearish volume trend [${VOLUME_POINTS} pts]`);
        }

        // 3. Final Signal Decision
        let signal: TradeSignal['signal'] = 'hold';
        let confidence: number;

        if (buyScore >= CONFIDENCE_THRESHOLD && buyScore > sellScore && trendBias === 'bullish') {
            signal = 'buy';
            confidence = Math.min(100, buyScore);
            reasons.push(`STRICT HTF FILTER: Signal confirmed by Bullish HTF Trend.`);
        } else if (sellScore >= CONFIDENCE_THRESHOLD && sellScore > buyScore && trendBias === 'bearish') {
            signal = 'sell';
            confidence = Math.min(100, sellScore);
            reasons.push(`STRICT HTF FILTER: Signal confirmed by Bearish HTF Trend.`);
        } else {
            confidence = Math.min(100, Math.max(buyScore, sellScore));
            reasons.push(`Score (${confidence}) below threshold ${CONFIDENCE_THRESHOLD} OR HTF Trend Conflict. Holding.`);
        }

        // 4. Risk Management (Based on ATR)
        this.lastAtr = atr.at(-1)!;
        const riskDistance = atrMultiplier * this.lastAtr;

        const stopLoss =
            signal === 'buy'
                ? price - riskDistance
                : signal === 'sell'
                    ? price + riskDistance
                    : undefined;

        const takeProfit =
            signal === 'buy'
                ? price + riskDistance * riskRewardTarget
                : signal === 'sell'
                    ? price - riskDistance * riskRewardTarget
                    : undefined;

        const trailingStopDistance =
            signal === 'buy' || signal === 'sell' ? price * (trailingStopPercent / 100) : undefined;


        // 5. Build and Return Signal
        return {
            symbol,
            signal,
            confidence,
            reason: reasons,
            stopLoss,
            takeProfit,
            trailingStopDistance,
        };
    }
}
