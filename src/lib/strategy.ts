// src/lib/strategy.ts

/**
 * Trading strategy module that generates trade signals based on multi-timeframe technical analysis.
 * Combines indicators from primary (3-minute) and higher (1-hour) timeframes for confluence.
 */
import type { OhlcvData } from '../types';
import {
    calculateEMA,
    calculateRSI,
    calculateMACD,
    calculateStochastic,
    calculateATR,
    calculateBollingerBands,
    calculateOBV,
    checkMACrossover,
    calculateADX, // NEW: Added ADX import
} from './indicators';
import * as ti from 'technicalindicators'; // For SMA in volume calc

/**
 * Defines the structure of a trade signal generated by the trading strategy.
 * Includes trading decision, confidence level, and risk management parameters.
 */
export interface TradeSignal {
    symbol: string;
    signal: 'buy' | 'sell' | 'hold';
    confidence: number;
    reason: string[];
    stopLoss?: number;
    takeProfit?: number;
    trailingStopDistance?: number;
    positionSizeMultiplier?: number;
}

/**
 * Defines the input structure for the trading strategy, incorporating multi-timeframe data.
 */
export interface StrategyInput {
    symbol: string;
    primaryData: OhlcvData; // 3-minute timeframe
    htfData: OhlcvData;     // 1-hour timeframe for trend filter
    price: number;
    atrMultiplier: number;
    riskRewardTarget: number;
    trailingStopPercent: number;
}


// Configuration Constants
const CONFIDENCE_THRESHOLD = 85;
const HTF_TREND_POINTS = 40;
const MA_TREND_POINTS = 25;
const MOMENTUM_POINTS = 20; // Reduced weight as we simplify the check
const VOLUME_POINTS = 15;
const TREND_STRENGTH_POINTS = 10;
const BB_POINTS = 15; // Points allocated for Bollinger Bands signals
const MAX_SCORE_PER_SIDE = HTF_TREND_POINTS + MA_TREND_POINTS + 3 * MOMENTUM_POINTS + VOLUME_POINTS + TREND_STRENGTH_POINTS + BB_POINTS // equals 140

const FIXED_RISK_PERCENT = 1.0;
const MAX_ATR_RISK_FACTOR = 1.0;

/**
 * Implements a trading strategy that generates trade signals using a weighted scoring system.
 * Analyzes multiple technical indicators across primary (3m) and higher (1h) timeframes.
 * Incorporates risk management with stop-loss, take-profit, and trailing stop mechanisms.
 */
export class Strategy {
    public readonly riskRewardTarget: number;
    public readonly atrMultiplier: number = 1.5;
    public readonly trailingStopPercent: number = 3;
    public lastAtr: null | number = null;

    // Configurable thresholds (omitting constructor for brevity, assuming original logic is here)
    public readonly rsiPeriod: number = 10;
    public readonly rsiOversold: number = 30;
    public readonly rsiOverbought: number = 70;
    public readonly macdFast: number = 5;
    public readonly macdSlow: number = 13;
    public readonly macdSignal: number = 8;
    public readonly stochPeriod: number = 14;
    public readonly stochSignal: number = 3;
    public readonly bbPeriod: number = 20;
    public readonly bbStdDev: number = 2;
    public readonly atrPeriod: number = 12;
    public readonly adxPeriod: number = 14;
    public readonly adxThreshold: number = 25;
    public readonly obvLookback: number = 10;
    public readonly volumeSurgeMultiplier: number = 1.5;
    public readonly minMomentumConfirms: number = 2; // Kept this check

    constructor(
        riskRewardTarget = 3,
        options: Partial<{
            rsiPeriod: number;
            rsiOversold: number;
            rsiOverbought: number;
            macdFast: number;
            macdSlow: number;
            macdSignal: number;
            stochPeriod: number;
            stochSignal: number;
            bbPeriod: number;
            bbStdDev: number;
            atrPeriod: number;
            adxPeriod: number;
            adxThreshold: number;
            obvLookback: number;
            volumeSurgeMultiplier: number;
            minMomentumConfirms: number;
        }> = {}
    ) {
        this.riskRewardTarget = riskRewardTarget;
        Object.assign(this, options);
    }

    /**
     * Generates a trade signal based on multi-timeframe and confluence analysis.
     * Uses primary (3-minute) and higher (1-hour) timeframe data to evaluate trend and momentum.
     * Applies risk management based on ATR and user-defined parameters.
     *
     * @param input - Data for primary (3m) and higher (1h) timeframes, plus configuration.
     * @returns TradeSignal with signal, confidence, reasons, and risk management levels.
     */
    public generateSignal(input: StrategyInput): TradeSignal {
        const { symbol, primaryData, htfData, price, atrMultiplier, riskRewardTarget } = input;
        let buyScore = 0;
        let sellScore = 0;
        const reasons: string[] = [];

        try {
            // --- 1. Higher Timeframe (HTF) Trend Filter (1-hour) ---
            const htfCloses = htfData.closes;
            const htfEma200 = calculateEMA(htfCloses, 200);

            if (htfCloses.length < 200 || htfEma200.length === 0) {
                reasons.push('Insufficient HTF data. Holding.');
                return { symbol, signal: 'hold', confidence: 0, reason: reasons };
            }

            const htfLastPrice = htfCloses.at(-1) ?? 0;
            const htfLastEma = htfEma200.at(-1) ?? 0;
            let trendBias: 'bullish' | 'bearish' | 'none' = 'none';

            if (htfLastPrice > htfLastEma) {
                trendBias = 'bullish';
                buyScore += HTF_TREND_POINTS;
                reasons.push(`HTF (1H) Trend: Bullish (Price above EMA200) [${HTF_TREND_POINTS} pts]`);
            } else if (htfLastPrice < htfLastEma) {
                trendBias = 'bearish';
                sellScore += HTF_TREND_POINTS;
                reasons.push(`HTF (1H) Trend: Bearish (Price below EMA200) [${HTF_TREND_POINTS} pts]`);
            } else {
                reasons.push('HTF Trend: Neutral/Consolidating [0 pts]');
            }

            // --- 2. Primary Timeframe (TTF) Confluence (3-minute) ---
            const ttfHighs = primaryData.highs;
            const ttfLows = primaryData.lows;
            const ttfCloses = primaryData.closes;
            const ttfVolumes = primaryData.volumes;

            if (ttfCloses.length < Math.max(this.rsiPeriod, this.macdSlow, this.stochPeriod, this.bbPeriod, this.atrPeriod, this.adxPeriod)) {
                reasons.push('Insufficient TTF data. Holding.');
                return { symbol, signal: 'hold', confidence: 0, reason: reasons };
            }

            // Indicator Calculations
            const ema50 = calculateEMA(ttfCloses, 50);
            const ema200 = calculateEMA(ttfCloses, 200);
            const rsi = calculateRSI(ttfCloses, this.rsiPeriod);
            const macd = calculateMACD(ttfCloses, this.macdFast, this.macdSlow, this.macdSignal);
            const stoch = calculateStochastic(ttfHighs, ttfLows, ttfCloses, this.stochPeriod, this.stochSignal);
            const atr = calculateATR(ttfHighs, ttfLows, ttfCloses, this.atrPeriod);
            const bb = calculateBollingerBands(ttfCloses, this.bbPeriod, this.bbStdDev);
            const adx = calculateADX(ttfHighs, ttfLows, ttfCloses, this.adxPeriod);
            const obv = calculateOBV(ttfCloses, ttfVolumes);

            const lastEma50 = ema50.at(-1) ?? 0;
            const lastEma200 = ema200.at(-1) ?? 0;

            // Volume surge check
            const volumeMa = ti.sma({ values: ttfVolumes, period: 20 });
            const lastVolume = ttfVolumes.at(-1) ?? 0;
            const volumeMaLast = volumeMa.at(-1) ?? 0;
            const hasVolumeSurge = lastVolume > volumeMaLast * this.volumeSurgeMultiplier;

            // --- Improvement 1: TTF MA Crossover & Price Location Filter ---
            const maCrossover = checkMACrossover(ema50, ema200);

            if (maCrossover === 'bullish' && price > lastEma50 && price > lastEma200) {
                buyScore += MA_TREND_POINTS;
                reasons.push(`TTF MA Trend: Bullish Crossover & Price above both EMAs [${MA_TREND_POINTS} pts]`);
            } else if (maCrossover === 'bearish' && price < lastEma50 && price < lastEma200) {
                sellScore += MA_TREND_POINTS;
                reasons.push(`TTF MA Trend: Bearish Crossover & Price below both EMAs [${MA_TREND_POINTS} pts]`);
            } else {
                reasons.push('TTF MA Trend: Neutral/Conflicting Price Position [0 pts]');
            }

            // --- Improvement 2: Trend Strength (ADX/DMI) ---
            const adxNow = adx.at(-1) ?? { adx: 0, pdi: 0, mdi: 0 };
            const isStrongTrend = adxNow.adx > this.adxThreshold;
            const isPlusDIBuy = adxNow.pdi > adxNow.mdi;
            const isMinusDISell = adxNow.mdi > adxNow.pdi;

            if (isStrongTrend && isPlusDIBuy) {
                buyScore += TREND_STRENGTH_POINTS;
                reasons.push(`TTF ADX/DMI: Strong Bullish Trend ($\text{ADX} > ${this.adxThreshold}$ & $\text{DI}+ > \text{DI}-$) [${TREND_STRENGTH_POINTS} pts]`);
            } else if (isStrongTrend && isMinusDISell) {
                sellScore += TREND_STRENGTH_POINTS;
                reasons.push(`TTF ADX/DMI: Strong Bearish Trend ($\text{ADX} > ${this.adxThreshold}$ & $\text{DI}- > \text{DI}+$) [${TREND_STRENGTH_POINTS} pts]`);
            } else {
                reasons.push('TTF ADX/DMI: Weak or Conflicting Trend [0 pts]');
            }


            // --- Improvement 4: Volatility & Mean Reversion (Bollinger Bands) ---
            const bbNow = bb.at(-1) ?? { middle: 0, upper: 0, lower: 0 };

            // 3A. Mean Reversion Check (Price near Bands)
            if (price <= bbNow.lower) {
                buyScore += BB_POINTS / 2; // Half points for touch/oversold
                reasons.push(`TTF BB: Price touched or below Lower Band (Oversold) [${BB_POINTS / 2} pts]`);
            } else if (price >= bbNow.upper) {
                sellScore += BB_POINTS / 2; // Half points for touch/overbought
                reasons.push(`TTF BB: Price touched or above Upper Band (Overbought) [${BB_POINTS / 2} pts]`);
            }

            // 3B. Volatility Squeeze Filter (Optional: Only trade if bands are wide, or vice versa)
            // A common measure: Band width relative to the middle band (SMA)
            const bbWidth = (bbNow.upper - bbNow.lower) / bbNow.middle * 100;
            const SQUEEZE_THRESHOLD_PERCENT = 1.0; // Example: Band width is less than 1.0% of the price

            if (bbWidth < SQUEEZE_THRESHOLD_PERCENT) {
                buyScore -= BB_POINTS / 2;
                sellScore -= BB_POINTS / 2;
                reasons.push(`TTF BB: Squeeze - Reduced confidence in both buy and sell signals [-${BB_POINTS / 2} pts each]`);
                reasons.push(`TTF BB: Volatility Squeeze detected (${bbWidth.toFixed(2)}%) - Exercise caution.`);
            }

            // --- Momentum Indicators (Simplified Confluence) ---
            let buyMomentumConfirms = 0;
            let sellMomentumConfirms = 0;

            // RSI: Oversold (Buy) or Overbought (Sell)
            const rsiNow = rsi.at(-1) ?? 0;
            if (rsiNow < this.rsiOversold) { buyMomentumConfirms++; reasons.push(`MOMENTUM: RSI Oversold (<${this.rsiOversold})`); }
            if (rsiNow > this.rsiOverbought) { sellMomentumConfirms++; reasons.push(`MOMENTUM: RSI Overbought (>${this.rsiOverbought})`); }

            // MACD: Histogram Positive (Buy) or Negative (Sell)
            const macdNow = macd.at(-1) ?? { histogram: 0 };
            if (macdNow.histogram! > 0) { buyMomentumConfirms++; reasons.push('MOMENTUM: MACD Histogram Positive'); }
            if (macdNow.histogram! < 0) { sellMomentumConfirms++; reasons.push('MOMENTUM: MACD Histogram Negative'); }

            // Stochastic: %K turning up from oversold (Buy) or down from overbought (Sell)
            const stochNow = stoch.at(-1) ?? { k: 0, d: 0 };
            if (stochNow.k < 20 && stochNow.k > stochNow.d) { buyMomentumConfirms++; reasons.push('MOMENTUM: Stochastic K turns up from <20'); }
            if (stochNow.k > 80 && stochNow.k < stochNow.d) { sellMomentumConfirms++; reasons.push('MOMENTUM: Stochastic K turns down from >80'); }

            // Apply Momentum Points based on Confirms and check for minimum
            if (buyMomentumConfirms >= this.minMomentumConfirms) {
                buyScore += MOMENTUM_POINTS * buyMomentumConfirms;
                reasons.push(`TTF Momentum: ${buyMomentumConfirms} Bullish Confirms [${MOMENTUM_POINTS * buyMomentumConfirms} pts]`);
            } else {
                reasons.push(`TTF Momentum: Insufficient Bullish Confirms (${buyMomentumConfirms}/${this.minMomentumConfirms})`);
            }
            if (sellMomentumConfirms >= this.minMomentumConfirms) {
                sellScore += MOMENTUM_POINTS * sellMomentumConfirms;
                reasons.push(`TTF Momentum: ${sellMomentumConfirms} Bearish Confirms [${MOMENTUM_POINTS * sellMomentumConfirms} pts]`);
            } else {
                reasons.push(`TTF Momentum: Insufficient Bearish Confirms (${sellMomentumConfirms}/${this.minMomentumConfirms})`);
            }

            // --- On-Balance Volume with surge ---
            if (obv.length >= this.obvLookback && obv.at(-1)! > obv.at(-this.obvLookback)! && hasVolumeSurge) {
                buyScore += VOLUME_POINTS;
                reasons.push(`TTF OBV rising with volume surge: Bullish volume trend [${VOLUME_POINTS} pts]`);
            } else if (obv.length >= this.obvLookback && obv.at(-1)! < obv.at(-this.obvLookback)! && hasVolumeSurge) {
                sellScore += VOLUME_POINTS;
                reasons.push(`TTF OBV falling with volume surge: Bearish volume trend [${VOLUME_POINTS} pts]`);
            }


            // --- 3. Final Signal Decision & Risk Management (ATR-based) ---
            let signal: TradeSignal['signal'] = 'hold';
            let confidence: number = Math.min(100, Math.max(buyScore, sellScore) / MAX_SCORE_PER_SIDE * 100);

            this.lastAtr = atr.at(-1) ?? null;
            if (this.lastAtr === null) {
                reasons.push('Insufficient ATR data. Holding.');
                return { symbol, signal, confidence: 0, reason: reasons };
            }

            // Risk Assessment
            const atrRiskDistance = atrMultiplier * this.lastAtr;
            const maxRiskDistance = price * (FIXED_RISK_PERCENT / 100);
            const riskEligible = atrRiskDistance <= maxRiskDistance * MAX_ATR_RISK_FACTOR;

            if (!riskEligible) {
                reasons.push(`❌ ATR Risk (${atrRiskDistance.toFixed(4)}) > Max ${FIXED_RISK_PERCENT}% Risk Cap. Holding.`);
            } else {
                reasons.push(`✅ ATR Risk (${atrRiskDistance.toFixed(4)}) is within Max ${FIXED_RISK_PERCENT}% Risk tolerance.`);
            }

            // Signal Logic (Strict HTF & Risk Filter)
            if (buyScore >= CONFIDENCE_THRESHOLD && buyScore > sellScore && trendBias === 'bullish' && riskEligible) {
                signal = 'buy';
                confidence = Math.min(100, buyScore / MAX_SCORE_PER_SIDE * 100);
                reasons.push(`STRICT FILTER CONFIRMED: Buy signal aligns with Bullish HTF Trend and acceptable volatility.`);
            } else if (sellScore >= CONFIDENCE_THRESHOLD && sellScore > buyScore && trendBias === 'bearish' && riskEligible) {
                signal = 'sell';
                confidence = Math.min(100, sellScore / MAX_SCORE_PER_SIDE * 100);
                reasons.push(`STRICT FILTER CONFIRMED: Sell signal aligns with Bearish HTF Trend and acceptable volatility.`);
            } else {
                reasons.push(`Score (${confidence.toFixed(1)}) below threshold ${CONFIDENCE_THRESHOLD} OR HTF Trend/Risk Conflict. Holding.`);
            }

            // Risk Levels (ATR-based for both SL and TP)
            const stopLoss =
                signal === 'buy' ? price - atrRiskDistance :
                    signal === 'sell' ? price + atrRiskDistance :
                        undefined;

            const takeProfit =
                signal === 'buy' ? price + (atrRiskDistance * riskRewardTarget) :
                    signal === 'sell' ? price - (atrRiskDistance * riskRewardTarget) :
                        undefined;

            // --- Improvement 3: Refined Trailing Stop Distance ---
            // Use the same distance as the initial SL for a more meaningful trailing stop.
            const trailingStopDistance =
                signal !== 'hold' ? atrRiskDistance : undefined; // Use the initial risk distance (ATR*Multiplier)

            const positionSizeMultiplier = confidence / 100;

            return {
                symbol,
                signal,
                confidence,
                reason: reasons,
                stopLoss,
                takeProfit,
                trailingStopDistance,
                positionSizeMultiplier,
            };
        } catch (error) {
            reasons.push(`Error in signal generation: ${(error as Error).message}. Holding.`);
            return { symbol, signal: 'hold', confidence: 0, reason: reasons };
        }
    }
}
