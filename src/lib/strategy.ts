import type { OhlcvData } from '../types';
import {
  calculateEMA,
  calculateRSI,
  calculateMACD,
  calculateStochastic,
  calculateATR,
  calculateOBV,
  calculateVWMA,
  calculateVWAP,
} from './indicators';
import { createLogger } from './logger';
import { MLService } from './services/mlService';

/**
 * Represents a trading signal generated by the Strategy class.
 */
export interface TradeSignal {
  symbol: string;
  signal: 'buy' | 'sell' | 'hold';
  confidence: number;
  reason: string[];
  stopLoss?: number;
  takeProfit?: number;
  trailingStopDistance?: number;
  positionSizeMultiplier?: number;
  mlConfidence?: number;
  features: number[];
}

/**
 * Input parameters for generating a trading signal.
 */
export interface StrategyInput {
  symbol: string;
  primaryData: OhlcvData;
  htfData: OhlcvData;
  price: number;
  atrMultiplier: number;
  riskRewardTarget: number;
  trailingStopPercent: number;
}

/**
 * Scoring constants for signal generation.
 */
const CONFIDENCE_THRESHOLD = 70;
const EMA_ALIGNMENT_POINTS = 25;
const VWMA_ALIGNMENT_POINTS = 10;
const MACD_POINTS = 15;
const RSI_POINTS = 10;
const STOCH_POINTS = 5;
const OBV_VWMA_POINTS = 10;
const ATR_POINTS = 10;
const VWAP_POSITION_POINTS = 5;
const VWMA_SLOPE_POINTS = 5;
const MAX_SCORE_PER_SIDE =
  EMA_ALIGNMENT_POINTS +
  VWMA_ALIGNMENT_POINTS +
  MACD_POINTS +
  RSI_POINTS +
  STOCH_POINTS +
  OBV_VWMA_POINTS +
  ATR_POINTS +
  VWAP_POSITION_POINTS +
  VWMA_SLOPE_POINTS;
const ML_CONFIDENCE_THRESHOLD = 0.7;
const MAX_ATR_MULTIPLIER = 5; // Prevent excessive stop-loss distances
const MIN_ATR_MULTIPLIER = 0.5; // Ensure reasonable stop-loss distances

const logger = createLogger('Strategy');

/**
 * Strategy class for generating trading signals based on technical indicators and ML predictions.
 * - Combines EMA, VWMA, VWAP, RSI, MACD, Stochastic, ATR, and OBV for signal scoring.
 * - Integrates with MLService for feature extraction and confidence scoring.
 * - Enforces risk management with ATR-based stop-loss and take-profit levels.
 * - Used by MarketScanner for trade execution and ML training.
 */
export class Strategy {
  /**
   * Risk-reward target for trades (e.g., 3 for 3:1 R:R).
   */
  public readonly riskRewardTarget: number;

  /**
   * ATR multiplier for stop-loss and take-profit calculations.
   */
  public readonly atrMultiplier: number = 1.5;

  /**
   * Trailing stop percentage (e.g., 3 for 3%).
   */
  public readonly trailingStopPercent: number = 3;

  /**
   * Last calculated ATR value for risk management.
   */
  public lastAtr: number | null = null;

  /**
   * Technical indicator parameters.
   */
  public readonly rsiPeriod: number = 10;
  public readonly rsiOversold: number = 30;
  public readonly rsiOverbought: number = 70;
  public readonly macdFast: number = 5;
  public readonly macdSlow: number = 13;
  public readonly macdSignal: number = 8;
  public readonly stochPeriod: number = 14;
  public readonly stochSignal: number = 3;
  public readonly atrPeriod: number = 12;
  public readonly obvLookback: number = 10;
  public readonly volumeSurgeMultiplier: number = 1.5;
  public readonly emaShortPeriod: number = 20;
  public readonly vwmaPeriod: number = 20;
  public readonly vwapPeriod: number = 20;
  public readonly htfEmaMidPeriod: number = 50;
  public readonly htfVwmaPeriod: number = 50;

  /**
   * Initializes the Strategy with MLService and configuration options.
   * @param mlService - MLService for feature extraction and predictions.
   * @param riskRewardTarget - Target risk-reward ratio (default: 3).
   * @param options - Optional indicator parameters.
   */
  constructor(
    private readonly mlService: MLService,
    riskRewardTarget = 3,
    options: Partial<{
      rsiPeriod: number;
      rsiOversold: number;
      rsiOverbought: number;
      macdFast: number;
      macdSlow: number;
      macdSignal: number;
      stochPeriod: number;
      stochSignal: number;
      atrPeriod: number;
      obvLookback: number;
      volumeSurgeMultiplier: number;
      emaShortPeriod: number;
      vwmaPeriod: number;
      vwapPeriod: number;
      htfEmaMidPeriod: number;
      htfVwmaPeriod: number;
      atrMultiplier: number;
      trailingStopPercent: number;
    }> = {}
  ) {
    this.riskRewardTarget = riskRewardTarget;
    Object.assign(this, options);
    logger.info('Strategy initialized', {
      riskRewardTarget,
      atrMultiplier: this.atrMultiplier,
      trailingStopPercent: this.trailingStopPercent,
    });
  }

  /**
   * Generates a trading signal based on technical indicators and ML predictions.
   * @param input - Input data including OHLCV, price, and risk parameters.
   * @returns {TradeSignal} The generated signal with confidence, stop-loss, take-profit, and features.
   */
  public generateSignal(input: StrategyInput): TradeSignal {
    const reasons: string[] = [];
    const { symbol, primaryData, htfData, price, atrMultiplier, riskRewardTarget } = input;

    try {
      // Validate input data
      const requiredLength = Math.max(
        this.emaShortPeriod,
        this.vwmaPeriod,
        this.rsiPeriod,
        this.atrPeriod,
        this.macdSlow + this.macdSignal
      );
      if (primaryData.closes.length < requiredLength || htfData.closes.length < this.htfEmaMidPeriod) {
        reasons.push('Insufficient data for indicator calculations');
        return { symbol, signal: 'hold', confidence: 0, reason: reasons, features: [] };
      }

      // Calculate technical indicators
      const emaShort = calculateEMA(primaryData.closes, this.emaShortPeriod);
      const htfEmaMid = calculateEMA(htfData.closes, this.htfEmaMidPeriod);
      const vwma = calculateVWMA(primaryData.closes, primaryData.volumes, this.vwmaPeriod);
      const vwap = calculateVWAP(primaryData.highs, primaryData.lows, primaryData.closes, primaryData.volumes, this.vwapPeriod);
      const rsi = calculateRSI(primaryData.closes, this.rsiPeriod);
      const macd = calculateMACD(primaryData.closes, this.macdFast, this.macdSlow, this.macdSignal);
      const stochastic = calculateStochastic(primaryData.highs, primaryData.lows, primaryData.closes, this.stochPeriod, this.stochSignal);
      const atr = calculateATR(primaryData.highs, primaryData.lows, primaryData.closes, this.atrPeriod);
      const obv = calculateOBV(primaryData.closes, primaryData.volumes);

      const lastEmaShort = emaShort.at(-1)!;
      const lastHtfEmaMid = htfEmaMid.at(-1)!;
      const lastVwma20 = vwma.at(-1)!;
      const lastVwap = vwap.at(-1)!;
      const rsiNow = rsi.at(-1)!;
      const macdNow = macd.at(-1);
      const stochNow = stochastic.at(-1)!;
      const lastObv = obv.at(-1)!;
      const lastAtr = atr.at(-1)!;

      // Validate ATR for risk management
      this.lastAtr = lastAtr;
      const adjustedAtrMultiplier = Math.min(Math.max(atrMultiplier, MIN_ATR_MULTIPLIER), MAX_ATR_MULTIPLIER);
      const atrRiskDistance = lastAtr * adjustedAtrMultiplier;
      const riskEligible = lastAtr > 0 && price / lastAtr >= 10 && lastAtr < price * 0.1; // Ensure ATR is reasonable

      // Trend and volume analysis
      const hasVolumeSurge = primaryData.volumes.at(-1)! > primaryData.volumes.at(-2)! * this.volumeSurgeMultiplier;
      const vwmaFalling = lastVwma20 < vwma.at(-2)!;
      const trendBias = lastEmaShort > lastHtfEmaMid ? 'bullish' : 'bearish';

      let buyScore = 0;
      let sellScore = 0;

      // Validate MACD data
      const isMacdValid =
        macdNow &&
        typeof macdNow.MACD === 'number' &&
        !isNaN(macdNow.MACD) &&
        typeof macdNow.signal === 'number' &&
        !isNaN(macdNow.signal);

      // Scoring logic for buy signals
      if (trendBias === 'bullish') {
        if (price > lastEmaShort && lastEmaShort > lastHtfEmaMid) {
          buyScore += EMA_ALIGNMENT_POINTS;
          reasons.push(`TREND: Price > EMA(${this.emaShortPeriod}) > HTF EMA(${this.htfEmaMidPeriod}) [${EMA_ALIGNMENT_POINTS} pts]`);
        }
        if (lastVwma20 > lastVwap) {
          buyScore += VWMA_ALIGNMENT_POINTS;
          reasons.push(`VWMA > VWAP: Bullish Conviction [${VWMA_ALIGNMENT_POINTS} pts]`);
        }
        if (isMacdValid && macdNow.MACD > macdNow.signal && macdNow.MACD > 0) {
          buyScore += MACD_POINTS;
          reasons.push(`MACD: Bullish Crossover and Above Zero [${MACD_POINTS} pts]`);
        } else if (!isMacdValid) {
          reasons.push('MACD: Invalid or missing data, skipping MACD scoring');
        }
        if (rsiNow < this.rsiOversold) {
          buyScore += RSI_POINTS;
          reasons.push(`MOMENTUM: RSI Oversold (<${this.rsiOversold}) [${RSI_POINTS} pts]`);
        }
        if (stochNow.k < 20 && stochNow.k > stochNow.d) {
          buyScore += STOCH_POINTS;
          reasons.push(`MOMENTUM: Stochastic K turns up from <20 [${STOCH_POINTS} pts]`);
        }
        if (obv.length >= this.obvLookback && lastObv > obv.at(-this.obvLookback)! && !vwmaFalling && hasVolumeSurge) {
          buyScore += OBV_VWMA_POINTS;
          reasons.push(`TTF OBV + VWMA rising with volume surge: Bullish volume trend [${OBV_VWMA_POINTS} pts]`);
        }
        if (riskEligible) {
          buyScore += ATR_POINTS;
          reasons.push(`ATR Volatility Control: Eligible [${ATR_POINTS} pts]`);
        }
        if (lastVwma20 > lastVwap) {
          buyScore += VWAP_POSITION_POINTS;
          reasons.push(`VWMA > VWAP: Bullish Conviction [${VWAP_POSITION_POINTS} pts]`);
        }
        if (!vwmaFalling) {
          buyScore += VWMA_SLOPE_POINTS;
          reasons.push(`VWMA Slope: Rising [${VWMA_SLOPE_POINTS} pts]`);
        }
      }
      // Scoring logic for sell signals
      else {
        if (price < lastEmaShort && lastEmaShort < lastHtfEmaMid) {
          sellScore += EMA_ALIGNMENT_POINTS;
          reasons.push(`TREND: Price < EMA(${this.emaShortPeriod}) < HTF EMA(${this.htfEmaMidPeriod}) [${EMA_ALIGNMENT_POINTS} pts]`);
        }
        if (isMacdValid && macdNow.MACD < macdNow.signal && macdNow.MACD < 0) {
          sellScore += MACD_POINTS;
          reasons.push(`MACD: Bearish Crossover and Below Zero [${MACD_POINTS} pts]`);
        } else if (!isMacdValid) {
          reasons.push('MACD: Invalid or missing data, skipping MACD scoring');
        }
        if (rsiNow > this.rsiOverbought) {
          sellScore += RSI_POINTS;
          reasons.push(`MOMENTUM: RSI Overbought (>${this.rsiOverbought}) [${RSI_POINTS} pts]`);
        }
        if (stochNow.k > 80 && stochNow.k < stochNow.d) {
          sellScore += STOCH_POINTS;
          reasons.push(`MOMENTUM: Stochastic K turns down from >80 [${STOCH_POINTS} pts]`);
        }
        if (obv.length >= this.obvLookback && lastObv < obv.at(-this.obvLookback)! && vwmaFalling && hasVolumeSurge) {
          sellScore += OBV_VWMA_POINTS;
          reasons.push(`TTF OBV + VWMA falling with volume surge: Bearish volume trend [${OBV_VWMA_POINTS} pts]`);
        }
        if (riskEligible) {
          sellScore += ATR_POINTS;
          reasons.push(`ATR Volatility Control: Eligible [${ATR_POINTS} pts]`);
        }
        if (lastVwma20 < lastVwap) {
          sellScore += VWAP_POSITION_POINTS;
          reasons.push(`VWMA < VWAP: Bearish Conviction [${VWAP_POSITION_POINTS} pts]`);
        }
        if (vwmaFalling) {
          sellScore += VWMA_SLOPE_POINTS;
          reasons.push(`VWMA Slope: Falling [${VWMA_SLOPE_POINTS} pts]`);
        }
      }

      // Extract features for ML
      const features = this.mlService.extractFeatures(input);
      let mlConfidence = 0;
      if (this.mlService.isModelTrained()) {
        const label = trendBias === 'bullish' ? 1 : -1;
        mlConfidence = this.mlService.predict(features, label);
        if (isNaN(mlConfidence) || mlConfidence < 0 || mlConfidence > 1) {
          logger.warn(`Invalid ML confidence for ${symbol}: ${mlConfidence}`);
          mlConfidence = 0;
          reasons.push('ML Confidence: Invalid prediction, ignoring ML score');
        } else {
          reasons.push(`ML Confidence: ${mlConfidence.toFixed(2)} (Threshold: ${ML_CONFIDENCE_THRESHOLD})`);
        }
      }

      // Determine signal and confidence
      let signal: TradeSignal['signal'] = 'hold';
      const maxScore = trendBias === 'bullish' ? buyScore : sellScore;
      let confidence: number = Math.min(100, (maxScore / MAX_SCORE_PER_SIDE) * 100);

      if (
        trendBias === 'bullish' &&
        buyScore >= CONFIDENCE_THRESHOLD &&
        riskEligible &&
        (!this.mlService.isModelTrained() || mlConfidence >= ML_CONFIDENCE_THRESHOLD)
      ) {
        signal = 'buy';
        confidence = Math.min(100, (buyScore / MAX_SCORE_PER_SIDE) * 100);
        reasons.push(`STRICT FILTER CONFIRMED: Buy signal aligns with Bullish HTF Trend and acceptable volatility`);
      } else if (
        trendBias === 'bearish' &&
        sellScore >= CONFIDENCE_THRESHOLD &&
        riskEligible &&
        (!this.mlService.isModelTrained() || mlConfidence >= ML_CONFIDENCE_THRESHOLD)
      ) {
        signal = 'sell';
        confidence = Math.min(100, (sellScore / MAX_SCORE_PER_SIDE) * 100);
        reasons.push(`STRICT FILTER CONFIRMED: Sell signal aligns with Bearish HTF Trend and acceptable volatility`);
      } else {
        if (maxScore >= 50 && maxScore < CONFIDENCE_THRESHOLD) {
          reasons.push(`Score (${maxScore}) between 50-69: Monitor for additional confluence`);
        } else if (this.mlService.isModelTrained() && mlConfidence < ML_CONFIDENCE_THRESHOLD) {
          reasons.push(`ML Confidence (${mlConfidence.toFixed(2)}) below threshold ${ML_CONFIDENCE_THRESHOLD}. Holding`);
        } else {
          reasons.push(`Score (${maxScore}) below threshold ${CONFIDENCE_THRESHOLD} OR HTF Trend/Risk Conflict. Holding`);
        }
      }

      // Calculate risk management parameters
      const stopLoss =
        signal === 'buy' ? price - atrRiskDistance : signal === 'sell' ? price + atrRiskDistance : undefined;
      const takeProfit =
        signal === 'buy'
          ? price + atrRiskDistance * riskRewardTarget
          : signal === 'sell'
            ? price - atrRiskDistance * riskRewardTarget
            : undefined;
      const trailingStopDistance = signal !== 'hold' ? atrRiskDistance * (1 - confidence / 200) : undefined;
      const positionSizeMultiplier = signal !== 'hold' ? Math.min(confidence / 100, 1) : undefined;

      logger.debug(`Generated signal for ${symbol}`, {
        signal,
        confidence: confidence.toFixed(2),
        mlConfidence: mlConfidence.toFixed(2),
        buyScore,
        sellScore,
        reasons,
      });

      return {
        symbol,
        signal,
        confidence,
        reason: reasons,
        stopLoss,
        takeProfit,
        trailingStopDistance,
        positionSizeMultiplier,
        mlConfidence: this.mlService.isModelTrained() ? mlConfidence : undefined,
        features,
      };
    } catch (error) {
      logger.error(`Error generating signal for ${symbol}`, { error });
      reasons.push(`Error in signal generation: ${(error as Error).message}. Holding`);
      return { symbol, signal: 'hold', confidence: 0, reason: reasons, features: [] };
    }
  }
}
