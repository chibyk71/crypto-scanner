// src/lib/strategy.ts

import type { OhlcvData } from '../types';
import {
    calculateEMA,
    calculateRSI,
    calculateMACD,
    calculateStochastic,
    calculateATR,
    calculateOBV,
    calculateVWMA,
    calculateVWAP,
} from './indicators';
import { createLogger } from './logger';
import { MLService } from './services/mlService';

/**
 * Represents a trading signal generated by the Strategy class.
 */
export interface TradeSignal {
    symbol: string;
    signal: 'buy' | 'sell' | 'hold';
    confidence: number;
    reason: string[];
    stopLoss?: number;
    takeProfit?: number;
    trailingStopDistance?: number;
    positionSizeMultiplier?: number;
    mlConfidence?: number;
    features: number[];
}

/**
 * Input parameters for generating a trading signal.
 */
export interface StrategyInput {
    symbol: string;
    primaryData: OhlcvData;
    htfData: OhlcvData;
    price: number;
    atrMultiplier: number;
    riskRewardTarget: number;
    trailingStopPercent: number;
}


/**
 * Interface for technical indicator results used in signal generation.
 */
interface Indicators {
    emaShort: number[];
    htfEmaMid: number[];
    vwma: number[];
    vwap: number[];
    rsi: number[];
    macd: Array<{ MACD: number; signal: number; histogram: number }>;
    stochastic: Array<{ k: number; d: number }>;
    atr: number[];
    obv: number[];
    lastEmaShort: number;
    lastHtfEmaMid: number;
    lastVwma20: number;
    lastVwap: number;
    rsiNow: number;
    macdNow: { MACD: number; signal: number; histogram: number } | undefined;
    stochNow: { k: number; d: number };
    lastObv: number;
    lastAtr: number;
}

/**
 * Interface for trend and volume analysis results.
 */
interface TrendAndVolume {
    hasVolumeSurge: boolean;
    vwmaFalling: boolean;
    trendBias: 'bullish' | 'bearish';
}

/**
 * Interface for scores and ML results.
 */
interface ScoresAndML {
    buyScore: number;
    sellScore: number;
    features: number[];
    mlConfidence: number;
}

/**
 * Scoring constants for signal generation.
 */
const CONFIDENCE_THRESHOLD = 70;
const EMA_ALIGNMENT_POINTS = 25;
const VWMA_VWAP_POINTS = 15; // Combined from previous 10 + 5
const MACD_POINTS = 15;
const RSI_POINTS = 10;
const STOCH_POINTS = 5;
const OBV_VWMA_POINTS = 10;
const ATR_POINTS = 10;
const VWMA_SLOPE_POINTS = 5;
const MAX_SCORE_PER_SIDE =
    EMA_ALIGNMENT_POINTS +
    VWMA_VWAP_POINTS +
    MACD_POINTS +
    RSI_POINTS +
    STOCH_POINTS +
    OBV_VWMA_POINTS +
    ATR_POINTS +
    VWMA_SLOPE_POINTS;
const ML_CONFIDENCE_THRESHOLD = 0.7;
const MAX_ATR_MULTIPLIER = 5;
const MIN_ATR_MULTIPLIER = 0.5;

const logger = createLogger('Strategy');

/**
 * Strategy class for generating trading signals based on technical indicators and ML predictions.
 * - Combines EMA, VWMA, VWAP, RSI, MACD, Stochastic, ATR, and OBV for signal scoring.
 * - Integrates with MLService for feature extraction and confidence scoring.
 * - Enforces risk management with ATR-based stop-loss and take-profit levels.
 * - Used by MarketScanner for trade execution and ML training.
 */
export class Strategy {
    /**
     * Risk-reward target for trades (e.g., 3 for 3:1 R:R).
     */
    public readonly riskRewardTarget: number;

    /**
     * ATR multiplier for stop-loss and take-profit calculations.
     */
    public readonly atrMultiplier: number = 1.5;

    /**
     * Trailing stop percentage (e.g., 3 for 3%).
     */
    public readonly trailingStopPercent: number = 3;

    /**
     * Last calculated ATR value for risk management.
     */
    public lastAtr: number | null = null;

    /**
     * Technical indicator parameters.
     */
    public readonly rsiPeriod: number = 10;
    public readonly rsiOversold: number = 30;
    public readonly rsiOverbought: number = 70;
    public readonly macdFast: number = 5;
    public readonly macdSlow: number = 13;
    public readonly macdSignal: number = 8;
    public readonly stochPeriod: number = 14;
    public readonly stochSignal: number = 3;
    public readonly atrPeriod: number = 12;
    public readonly obvLookback: number = 10;
    public readonly volumeSurgeMultiplier: number = 1.5;
    public readonly emaShortPeriod: number = 20;
    public readonly vwmaPeriod: number = 20;
    public readonly vwapPeriod: number = 20;
    public readonly htfEmaMidPeriod: number = 50;
    public readonly htfVwmaPeriod: number = 50;

    /**
     * Initializes the Strategy with MLService and configuration options.
     * @param mlService - MLService for feature extraction and predictions.
     * @param riskRewardTarget - Target risk-reward ratio (default: 3).
     * @param options - Optional indicator parameters.
     */
    constructor(
        private readonly mlService: MLService,
        riskRewardTarget = 3,
        options: Partial<{
            rsiPeriod: number;
            rsiOversold: number;
            rsiOverbought: number;
            macdFast: number;
            macdSlow: number;
            macdSignal: number;
            stochPeriod: number;
            stochSignal: number;
            atrPeriod: number;
            obvLookback: number;
            volumeSurgeMultiplier: number;
            emaShortPeriod: number;
            vwmaPeriod: number;
            vwapPeriod: number;
            htfEmaMidPeriod: number;
            htfVwmaPeriod: number;
            atrMultiplier: number;
            trailingStopPercent: number;
        }> = {}
    ) {
        this.riskRewardTarget = riskRewardTarget;
        Object.assign(this, options);
        logger.info('Strategy initialized', {
            riskRewardTarget,
            atrMultiplier: this.atrMultiplier,
            trailingStopPercent: this.trailingStopPercent,
        });
    }

    /**
     * Calculates technical indicators required for signal generation.
     * @param primaryData - OHLCV data for the primary timeframe.
     * @param htfData - OHLCV data for the higher timeframe.
     * @returns Indicators object containing all calculated indicator values and their latest values.
     * @throws Error if indicator calculations fail.
     */
    private _calculateIndicators(primaryData: OhlcvData, htfData: OhlcvData): Indicators {
        // Calculate all technical indicators using provided OHLCV data
        const emaShort = calculateEMA(primaryData.closes, this.emaShortPeriod); // Short-term EMA (20-period)
        const htfEmaMid = calculateEMA(htfData.closes, this.htfEmaMidPeriod); // Higher timeframe EMA (50-period)
        const vwma = calculateVWMA(primaryData.closes, primaryData.volumes, this.vwmaPeriod); // Volume-weighted MA (20-period)
        const vwap = calculateVWAP(primaryData.highs, primaryData.lows, primaryData.closes, primaryData.volumes, this.vwapPeriod); // Volume-weighted average price
        const rsi = calculateRSI(primaryData.closes, this.rsiPeriod); // Relative Strength Index (10-period)
        const macd = calculateMACD(primaryData.closes, this.macdFast, this.macdSlow, this.macdSignal); // MACD (5,13,8)
        const stochastic = calculateStochastic(primaryData.highs, primaryData.lows, primaryData.closes, this.stochPeriod, this.stochSignal); // Stochastic (14,3)
        const atr = calculateATR(primaryData.highs, primaryData.lows, primaryData.closes, this.atrPeriod); // Average True Range (12-period)
        const obv = calculateOBV(primaryData.closes, primaryData.volumes); // On-Balance Volume

        // Extract the latest values for each indicator for scoring and risk calculations
        const lastEmaShort = emaShort.at(-1)!; // Latest short-term EMA value
        const lastHtfEmaMid = htfEmaMid.at(-1)!; // Latest higher timeframe EMA value
        const lastVwma20 = vwma.at(-1)!; // Latest VWMA value
        const lastVwap = vwap.at(-1)!; // Latest VWAP value
        const rsiNow = rsi.at(-1)!; // Latest RSI value
        const macdNow = macd.at(-1); // Latest MACD values (MACD line, signal line, histogram)
        const stochNow = stochastic.at(-1)!; // Latest Stochastic values (%K, %D)
        const lastObv = obv.at(-1)!; // Latest OBV value
        const lastAtr = atr.at(-1)!; // Latest ATR value

        // Return structured object with all indicator data
        return {
            emaShort,
            htfEmaMid,
            vwma,
            vwap,
            rsi,
            macd,
            stochastic,
            atr,
            obv,
            lastEmaShort,
            lastHtfEmaMid,
            lastVwma20,
            lastVwap,
            rsiNow,
            macdNow,
            stochNow,
            lastObv,
            lastAtr,
        };
    }

    /**
     * Performs trend and volume analysis to determine market context.
     * @param primaryData - OHLCV data for the primary timeframe.
     * @param indicators - Calculated indicator values.
     * @param price - Current market price.
     * @returns TrendAndVolume object containing trend bias, volume surge, and VWMA slope.
     */
    private _analyzeTrendAndVolume(primaryData: OhlcvData, indicators: Indicators, _price: number): TrendAndVolume {
        // Check for volume surge (current volume > previous volume * multiplier)
        const hasVolumeSurge = primaryData.volumes.at(-1)! > primaryData.volumes.at(-2)! * this.volumeSurgeMultiplier;
        // Determine if VWMA is falling (bearish signal)
        const vwmaFalling = indicators.lastVwma20 < indicators.vwma.at(-2)!;
        // Determine trend bias based on short-term EMA vs higher timeframe EMA
        const trendBias = indicators.lastEmaShort > indicators.lastHtfEmaMid ? 'bullish' : 'bearish';

        return { hasVolumeSurge, vwmaFalling, trendBias };
    }

    /**
     * Computes buy and sell scores based on technical indicators and ML predictions.
     * @param indicators - Calculated indicator values.
     * @param trendAndVolume - Trend and volume analysis results.
     * @param input - Strategy input data.
     * @param reasons - Array to store scoring reasons.
     * @returns ScoresAndML object with buy/sell scores, ML features, and ML confidence.
     */
    private _computeScores(
        indicators: Indicators,
        trendAndVolume: TrendAndVolume,
        input: StrategyInput,
        reasons: string[]
    ): ScoresAndML {
        let buyScore = 0;
        let sellScore = 0;

        // Validate MACD data for scoring
        const isMacdValid =
            indicators.macdNow &&
            typeof indicators.macdNow.MACD === 'number' &&
            !isNaN(indicators.macdNow.MACD) &&
            typeof indicators.macdNow.signal === 'number' &&
            !isNaN(indicators.macdNow.signal);

        if (trendAndVolume.trendBias === 'bullish') {
            // EMA alignment
            if (input.price > indicators.lastEmaShort && indicators.lastEmaShort > indicators.lastHtfEmaMid) {
                buyScore += EMA_ALIGNMENT_POINTS;
                reasons.push(
                    `TREND: Price > EMA(${this.emaShortPeriod}) > HTF EMA(${this.htfEmaMidPeriod}) [${EMA_ALIGNMENT_POINTS} pts]`
                );
            }

            // Combined VWMA > VWAP: Bullish conviction
            if (indicators.lastVwma20 > indicators.lastVwap) {
                buyScore += VWMA_VWAP_POINTS;
                reasons.push(`VWMA > VWAP: Strong Bullish Conviction [${VWMA_VWAP_POINTS} pts]`);
            }

            // Tiered MACD scoring
            if (isMacdValid) {
                const macd = indicators.macdNow!;
                if (macd.MACD > macd.signal && macd.MACD > 0) {
                    buyScore += MACD_POINTS;
                    reasons.push(`MACD: Bullish Crossover and Above Zero [${MACD_POINTS} pts]`);
                } else if (macd.MACD > macd.signal) {
                    buyScore += 8;
                    reasons.push(`MACD: Bullish Crossover [8 pts]`);
                } else if (macd.MACD > 0) {
                    buyScore += 3;
                    reasons.push(`MACD: Above Zero Line [3 pts]`);
                }
            } else {
                reasons.push('MACD: Invalid or missing data, skipping MACD scoring');
            }

            // RSI Oversold
            if (indicators.rsiNow < this.rsiOversold) {
                buyScore += RSI_POINTS;
                reasons.push(`MOMENTUM: RSI Oversold (<${this.rsiOversold}) [${RSI_POINTS} pts]`);
            }

            // Stochastic bullish reversal
            if (indicators.stochNow.k < 20 && indicators.stochNow.k > indicators.stochNow.d) {
                buyScore += STOCH_POINTS;
                reasons.push(`MOMENTUM: Stochastic K turns up from <20 [${STOCH_POINTS} pts]`);
            }

            // Tiered Volume/VWMA scoring
            const obvRising = indicators.obv.length >= this.obvLookback && indicators.lastObv > indicators.obv.at(-this.obvLookback)!;
            const volumeConfluence = obvRising && !trendAndVolume.vwmaFalling;
            if (volumeConfluence && trendAndVolume.hasVolumeSurge) {
                buyScore += OBV_VWMA_POINTS;
                reasons.push(`VOLUME: OBV + VWMA rising with volume surge: Bullish volume trend [${OBV_VWMA_POINTS} pts]`);
            } else if (volumeConfluence) {
                buyScore += 6;
                reasons.push(`VOLUME: OBV + VWMA Rising [6 pts]`);
            } else if (obvRising || trendAndVolume.hasVolumeSurge) {
                buyScore += 3;
                reasons.push(`VOLUME: OBV Rising OR Surge [3 pts]`);
            }

            // ATR Volatility Control
            if (this._isRiskEligible(input.price, indicators.lastAtr)) {
                buyScore += ATR_POINTS;
                reasons.push(`ATR Volatility Control: Eligible [${ATR_POINTS} pts]`);
            }

            // VWMA Slope: Rising
            if (!trendAndVolume.vwmaFalling) {
                buyScore += VWMA_SLOPE_POINTS;
                reasons.push(`VWMA Slope: Rising [${VWMA_SLOPE_POINTS} pts]`);
            }
        } else {
            // Bearish scoring - mirror the bullish logic with inversions

            // EMA alignment
            if (input.price < indicators.lastEmaShort && indicators.lastEmaShort < indicators.lastHtfEmaMid) {
                sellScore += EMA_ALIGNMENT_POINTS;
                reasons.push(
                    `TREND: Price < EMA(${this.emaShortPeriod}) < HTF EMA(${this.htfEmaMidPeriod}) [${EMA_ALIGNMENT_POINTS} pts]`
                );
            }

            // Combined VWMA < VWAP: Bearish conviction
            if (indicators.lastVwma20 < indicators.lastVwap) {
                sellScore += VWMA_VWAP_POINTS;
                reasons.push(`VWMA < VWAP: Strong Bearish Conviction [${VWMA_VWAP_POINTS} pts]`);
            }

            // Tiered MACD scoring
            if (isMacdValid) {
                const macd = indicators.macdNow!;
                if (macd.MACD < macd.signal && macd.MACD < 0) {
                    sellScore += MACD_POINTS;
                    reasons.push(`MACD: Bearish Crossover and Below Zero [${MACD_POINTS} pts]`);
                } else if (macd.MACD < macd.signal) {
                    sellScore += 8;
                    reasons.push(`MACD: Bearish Crossover [8 pts]`);
                } else if (macd.MACD < 0) {
                    sellScore += 3;
                    reasons.push(`MACD: Below Zero Line [3 pts]`);
                }
            } else {
                reasons.push('MACD: Invalid or missing data, skipping MACD scoring');
            }

            // RSI Overbought
            if (indicators.rsiNow > this.rsiOverbought) {
                sellScore += RSI_POINTS;
                reasons.push(`MOMENTUM: RSI Overbought (>${this.rsiOverbought}) [${RSI_POINTS} pts]`);
            }

            // Stochastic bearish reversal
            if (indicators.stochNow.k > 80 && indicators.stochNow.k < indicators.stochNow.d) {
                sellScore += STOCH_POINTS;
                reasons.push(`MOMENTUM: Stochastic K turns down from >80 [${STOCH_POINTS} pts]`);
            }

            // Tiered Volume/VWMA scoring
            const obvFalling = indicators.obv.length >= this.obvLookback && indicators.lastObv < indicators.obv.at(-this.obvLookback)!;
            const volumeConfluence = obvFalling && trendAndVolume.vwmaFalling;
            if (volumeConfluence && trendAndVolume.hasVolumeSurge) {
                sellScore += OBV_VWMA_POINTS;
                reasons.push(`VOLUME: OBV + VWMA falling with volume surge: Bearish volume trend [${OBV_VWMA_POINTS} pts]`);
            } else if (volumeConfluence) {
                sellScore += 6;
                reasons.push(`VOLUME: OBV + VWMA Falling [6 pts]`);
            } else if (obvFalling || trendAndVolume.hasVolumeSurge) {
                sellScore += 3;
                reasons.push(`VOLUME: OBV Falling OR Surge [3 pts]`);
            }

            // ATR Volatility Control
            if (this._isRiskEligible(input.price, indicators.lastAtr)) {
                sellScore += ATR_POINTS;
                reasons.push(`ATR Volatility Control: Eligible [${ATR_POINTS} pts]`);
            }

            // VWMA Slope: Falling
            if (trendAndVolume.vwmaFalling) {
                sellScore += VWMA_SLOPE_POINTS;
                reasons.push(`VWMA Slope: Falling [${VWMA_SLOPE_POINTS} pts]`);
            }
        }

        // Extract ML features and compute ML confidence
        const features = this.mlService.extractFeatures(input);
        let mlConfidence = 0;
        if (this.mlService.isModelTrained()) {
            const label = trendAndVolume.trendBias === 'bullish' ? 1 : -1;
            mlConfidence = this.mlService.predict(features, label);
            if (isNaN(mlConfidence) || mlConfidence < 0 || mlConfidence > 1) {
                logger.warn(`Invalid ML confidence for ${input.symbol}: ${mlConfidence}`);
                mlConfidence = 0;
                reasons.push('ML Confidence: Invalid prediction, ignoring ML score');
            } else {
                reasons.push(`ML Confidence: ${mlConfidence.toFixed(2)} (Threshold: ${ML_CONFIDENCE_THRESHOLD})`);
            }
        }

        return { buyScore, sellScore, features, mlConfidence };
    }

    /**
     * Validates ATR for risk management eligibility.
     * @param price - Current market price.
     * @param lastAtr - Latest ATR value.
     * @returns Boolean indicating if the ATR is suitable for risk calculations.
     */
    private _isRiskEligible(price: number, lastAtr: number): boolean {
        // 1. Safety Check: Ensure ATR is positive before division.
        if (lastAtr <= 0) {
            return false;
        }

        // 2. Calculate the Ratio (Price is how many ATRs).
        const atrRatio = price / lastAtr;

        // 3. Filter: ATR must be between 1% (ratio >= 100) and 10% (ratio <= 10) of price.
        // Price / ATR >= 10   -> ATR <= 10% of Price (Upper Volatility Limit)
        // Price / ATR <= 100  -> ATR >= 1% of Price  (Lower Volatility Limit)
        return atrRatio >= 10 && atrRatio <= 1000;
    }

    /**
     * Determines the final trading signal based on scores and ML confidence.
     * @param buyScore - Buy signal score.
     * @param sellScore - Sell signal score.
     * @param trendBias - Market trend ('bullish' or 'bearish').
     * @param mlConfidence - ML prediction confidence.
     * @param riskEligible - Whether ATR is suitable for risk management.
     * @param reasons - Array to store signal decision reasons.
     * @returns Object containing the signal and confidence score.
     */
    private _determineSignal(
        buyScore: number,
        sellScore: number,
        trendBias: 'bullish' | 'bearish',
        mlConfidence: number,
        riskEligible: boolean,
        reasons: string[]
    ): { signal: TradeSignal['signal']; confidence: number } {
        let signal: TradeSignal['signal'] = 'hold';
        const maxScore = trendBias === 'bullish' ? buyScore : sellScore;
        let confidence = Math.min(100, (maxScore / MAX_SCORE_PER_SIDE) * 100);

        // Check conditions for a buy signal
        if (
            trendBias === 'bullish' &&
            buyScore >= CONFIDENCE_THRESHOLD &&
            riskEligible &&
            (!this.mlService.isModelTrained() || mlConfidence >= ML_CONFIDENCE_THRESHOLD)
        ) {
            signal = 'buy';
            confidence = Math.min(100, (buyScore / MAX_SCORE_PER_SIDE) * 100);
            reasons.push(`STRICT FILTER CONFIRMED: Buy signal aligns with Bullish HTF Trend and acceptable volatility`);
        }
        // Check conditions for a sell signal
        else if (
            trendBias === 'bearish' &&
            sellScore >= CONFIDENCE_THRESHOLD &&
            riskEligible &&
            (!this.mlService.isModelTrained() || mlConfidence >= ML_CONFIDENCE_THRESHOLD)
        ) {
            signal = 'sell';
            confidence = Math.min(100, (sellScore / MAX_SCORE_PER_SIDE) * 100);
            reasons.push(`STRICT FILTER CONFIRMED: Sell signal aligns with Bearish HTF Trend and acceptable volatility`);
        }
        // Provide reasons for holding
        else {
            if (maxScore >= 50 && maxScore < CONFIDENCE_THRESHOLD) {
                reasons.push(`Score (${maxScore}) between 50-69: Monitor for additional confluence`);
            } else if (this.mlService.isModelTrained() && mlConfidence < ML_CONFIDENCE_THRESHOLD) {
                reasons.push(`ML Confidence (${mlConfidence.toFixed(2)}) below threshold ${ML_CONFIDENCE_THRESHOLD}. Holding`);
            } else {
                reasons.push(`Score (${maxScore}) below threshold ${CONFIDENCE_THRESHOLD} OR HTF Trend/Risk Conflict. Holding`);
            }
        }

        return { signal, confidence };
    }

    /**
     * Computes risk management parameters (stop-loss, take-profit, etc.) based on signal and ATR.
     * @param signal - Trading signal ('buy', 'sell', or 'hold').
     * @param price - Current market price.
     * @param atrMultiplier - ATR multiplier for risk calculations.
     * @param riskRewardTarget - Desired risk-reward ratio.
     * @param confidence - Signal confidence score.
     * @param lastAtr - Latest ATR value.
     * @returns Object containing risk management parameters.
     */
    private _computeRiskParams(
        signal: TradeSignal['signal'],
        price: number,
        atrMultiplier: number,
        riskRewardTarget: number,
        confidence: number,
        lastAtr: number
    ): {
        stopLoss?: number;
        takeProfit?: number;
        trailingStopDistance?: number;
        positionSizeMultiplier?: number;
    } {
        // Adjust ATR multiplier to stay within defined limits
        const adjustedAtrMultiplier = Math.min(Math.max(atrMultiplier, MIN_ATR_MULTIPLIER), MAX_ATR_MULTIPLIER);
        const atrRiskDistance = lastAtr * adjustedAtrMultiplier;

        // Calculate risk parameters only for buy or sell signals
        const stopLoss = signal === 'buy' ? price - atrRiskDistance : signal === 'sell' ? price + atrRiskDistance : undefined;
        const takeProfit =
            signal === 'buy'
                ? price + atrRiskDistance * riskRewardTarget
                : signal === 'sell'
                    ? price - atrRiskDistance * riskRewardTarget
                    : undefined;
        const trailingStopDistance = signal !== 'hold' ? atrRiskDistance * (1 - confidence / 200) : undefined;
        const positionSizeMultiplier = signal !== 'hold' ? Math.min(confidence / 100, 1) : undefined;

        return { stopLoss, takeProfit, trailingStopDistance, positionSizeMultiplier };
    }

    /**
     * Generates a trading signal based on technical indicators and ML predictions.
     * @param input - Input data including OHLCV, price, and risk parameters.
     * @returns TradeSignal object with signal, confidence, risk parameters, and features.
     */
    public generateSignal(input: StrategyInput): TradeSignal {
        const reasons: string[] = [];
        const { symbol, primaryData, htfData, price, atrMultiplier, riskRewardTarget } = input;

        try {
            // Validate input data length for indicator calculations
            const requiredLength = Math.max(
                this.emaShortPeriod,
                this.vwmaPeriod,
                this.rsiPeriod,
                this.atrPeriod,
                this.macdSlow + this.macdSignal
            );
            if (primaryData.closes.length < requiredLength || htfData.closes.length < this.htfEmaMidPeriod) {
                reasons.push('Insufficient data for indicator calculations');
                return { symbol, signal: 'hold', confidence: 0, reason: reasons, features: [] };
            }

            // Calculate technical indicators
            const indicators = this._calculateIndicators(primaryData, htfData);

            // Store latest ATR for risk management
            this.lastAtr = indicators.lastAtr;

            // Analyze trend and volume
            const trendAndVolume = this._analyzeTrendAndVolume(primaryData, indicators, price);

            // Compute buy/sell scores and ML confidence
            const { buyScore, sellScore, features, mlConfidence } = this._computeScores(indicators, trendAndVolume, input, reasons);

            // Determine the final signal and confidence
            const { signal, confidence } = this._determineSignal(
                buyScore,
                sellScore,
                trendAndVolume.trendBias,
                mlConfidence,
                this._isRiskEligible(price, indicators.lastAtr),
                reasons
            );

            // Compute risk management parameters
            const { stopLoss, takeProfit, trailingStopDistance, positionSizeMultiplier } = this._computeRiskParams(
                signal,
                price,
                atrMultiplier,
                riskRewardTarget,
                confidence,
                indicators.lastAtr
            );

            // Log the generated signal for debugging
            logger.debug(`Generated signal for ${symbol}`, {
                signal,
                confidence: confidence.toFixed(2),
                mlConfidence: mlConfidence.toFixed(2),
                buyScore,
                sellScore,
                reasons,
            });

            // Return the final trade signal
            return {
                symbol,
                signal,
                confidence,
                reason: reasons,
                stopLoss,
                takeProfit,
                trailingStopDistance,
                positionSizeMultiplier,
                mlConfidence: this.mlService.isModelTrained() ? mlConfidence : undefined,
                features,
            };
        } catch (error) {
            // Handle errors by logging and returning a hold signal
            logger.error(`Error generating signal for ${symbol}`, { error });
            reasons.push(`Error in signal generation: ${(error as Error).message}. Holding`);
            return { symbol, signal: 'hold', confidence: 0, reason: reasons, features: [] };
        }
    }
}
